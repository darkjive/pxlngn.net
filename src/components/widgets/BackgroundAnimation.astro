---
/**
 * Space Background Animation - Enhanced with Megalophobia
 *
 * Erzeugt einen intensiven animierten Weltraum-Hintergrund mit anime.js:
 * - Mehrere Ebenen von Sternen für Tiefeneffekt (Parallax)
 * - Riesige, langsam vorbeiziehende Planeten (Megalophobie)
 * - Schnelle Meteore mit Schweif
 * - Alien-artige Plasma-Wesen (pulsierend, verschiedene Farben)
 *
 * Vermittelt das Gefühl von beklemmender Weite und Isolation im Weltraum.
 */
---

<div id="space-bg" class="fixed inset-0 -z-50 hidden overflow-hidden bg-gradient-to-b from-black via-slate-950 to-black dark:block"></div>

<script>
  import { animate } from 'animejs';

  /**
   * Konfiguration für Partikeltypen mit Tiefen-Layering
   * Statische Sterne + vertikale Bewegung (oben nach unten)
   */
  const CONFIG = {
    // Statische Sterne im Hintergrund (verschiedene Ebenen für Tiefe)
    starsDistant: {
      count: 300,
      minSize: 0.3,
      maxSize: 2,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#dbeafe', '#f0f9ff'],
      opacity: [0.15, 0.5],
      twinkle: true, // Leichtes Twinkle für Leben
    },
    starsMid: {
      count: 200,
      minSize: 0.8,
      maxSize: 3,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#fef3c7', '#fef9c3', '#fefce8'],
      opacity: [0.3, 0.75],
      twinkle: true,
    },
    starsNear: {
      count: 120,
      minSize: 1.5,
      maxSize: 5,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#fef3c7', '#fde68a', '#fcd34d'],
      opacity: [0.5, 1],
      twinkle: true,
    },
    // Vorbeiziehende Partikel (Staub/Nebel) - Parallax von oben nach unten
    particles: {
      count: 80,
      minSize: 1,
      maxSize: 3,
      speed: [8000, 15000], // Langsam (weit weg)
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe'],
      opacity: [0.3, 0.6],
    },
    particlesMid: {
      count: 60,
      minSize: 2,
      maxSize: 4,
      speed: [5000, 10000], // Mittel
      colors: ['#ffffff', '#e0f2fe', '#fef3c7'],
      opacity: [0.4, 0.7],
    },
    particlesNear: {
      count: 40,
      minSize: 3,
      maxSize: 6,
      speed: [2000, 5000], // Schnell (nah)
      colors: ['#ffffff', '#fef3c7'],
      opacity: [0.6, 0.9],
    },
    // Riesige Planeten (Megalophobie!) - von oben nach unten
    planets: {
      count: 4,
      minSize: 300,
      maxSize: 800,
      speed: [60000, 120000], // Sehr langsam, majestätisch
      types: [
        { colors: ['#1e3a8a', '#3b82f6', '#1e40af'], name: 'gas-giant' },
        { colors: ['#dc2626', '#f87171', '#7f1d1d'], name: 'red-planet' },
        { colors: ['#f59e0b', '#fbbf24', '#92400e'], name: 'desert-world' },
        { colors: ['#059669', '#10b981', '#064e3b'], name: 'toxic-world' },
        { colors: ['#6366f1', '#a855f7', '#4c1d95'], name: 'purple-giant' },
      ],
    },
    // Schwarzes Loch
    blackHole: {
      count: 1,
      minSize: 400,
      maxSize: 600,
      speed: [80000, 150000],
    },
    // Meteore mit zufälligen Flugbahnen
    meteors: {
      count: 8,
      width: 2,
      height: [40, 120],
      speed: [1200, 3000],
      colors: ['#60a5fa', '#3b82f6', '#2563eb', '#ffffff', '#f0f9ff'],
      delay: [0, 20000],
    },
  };

  /**
   * Maus-Position für Gravitations-Effekt
   */
  let mouseX = 0;
  let mouseY = 0;

  /**
   * Erstellt einen statischen Stern mit leichtem Twinkle-Effekt
   */
  function createStar(container: HTMLElement, config: typeof CONFIG.starsDistant) {
    const star = document.createElement('div');
    const size = config.minSize + Math.random() * (config.maxSize - config.minSize);
    const color = config.colors[Math.floor(Math.random() * config.colors.length)];
    const opacity = config.opacity[0] + Math.random() * (config.opacity[1] - config.opacity[0]);

    star.style.cssText = `
      position: absolute;
      width: ${size}px;
      height: ${size}px;
      background: ${color};
      border-radius: 50%;
      box-shadow: 0 0 ${size * 2}px ${color};
      top: ${Math.random() * 100}%;
      left: ${Math.random() * 100}%;
      opacity: ${opacity};
      z-index: 1;
    `;

    container.appendChild(star);

    // Leichtes Twinkle für Leben (optional)
    if (config.twinkle && Math.random() > 0.7) {
      const twinkleDuration = 2000 + Math.random() * 3000;
      animate(star, {
        opacity: [
          { to: opacity * 1.3, duration: twinkleDuration * 0.5 },
          { to: opacity * 0.7, duration: twinkleDuration * 0.5 },
        ],
        duration: twinkleDuration,
        ease: 'inOutSine',
        loop: true,
      });
    }
  }

  /**
   * Erstellt vorbeiziehende Partikel (von oben nach unten) - Parallax-Effekt mit Gravitation
   */
  function createParticle(container: HTMLElement, config: any, zIndex: number) {
    const particle = document.createElement('div');
    const size = config.minSize + Math.random() * (config.maxSize - config.minSize);
    const color = config.colors[Math.floor(Math.random() * config.colors.length)];
    const opacity = config.opacity[0] + Math.random() * (config.opacity[1] - config.opacity[0]);

    const startLeft = Math.random() * 100;
    let currentX = startLeft;
    let currentY = -5 - Math.random() * 5;

    particle.style.cssText = `
      position: absolute;
      width: ${size}px;
      height: ${size}px;
      background: ${color};
      border-radius: 50%;
      box-shadow: 0 0 ${size * 2}px ${color};
      top: ${currentY}%;
      left: ${startLeft}%;
      opacity: ${opacity};
      z-index: ${zIndex};
      will-change: transform;
    `;

    container.appendChild(particle);

    const duration = config.speed[0] + Math.random() * (config.speed[1] - config.speed[0]);
    const horizontalDrift = (Math.random() - 0.5) * 100;
    const startTime = Date.now();

    // Stärke der Gravitation basierend auf Partikel-Ebene (näher = stärker)
    const gravityStrength = zIndex * 0.02; // z-index 2 = 0.04, z-index 4 = 0.08

    // Frame-Update-Funktion für Gravitations-Effekt
    const updateFrame = () => {
      const elapsed = Date.now() - startTime;
      const progress = (elapsed % duration) / duration;

      // Berechne Position basierend auf Zeit
      const baseY = progress * window.innerHeight * 1.2;
      const baseX = progress * horizontalDrift;

      // Berechne Gravitations-Offset basierend auf Maus-Position
      const rect = particle.getBoundingClientRect();
      const particleScreenX = rect.left + rect.width / 2;
      const particleScreenY = rect.top + rect.height / 2;

      const dx = mouseX - particleScreenX;
      const dy = mouseY - particleScreenY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Gravitation nimmt mit Distanz ab (inverse square approximation)
      const gravityRange = 300;
      if (distance < gravityRange && distance > 0) {
        const force = (1 - distance / gravityRange) * gravityStrength * 50;
        const gravityX = (dx / distance) * force;
        const gravityY = (dy / distance) * force;

        particle.style.transform = `translate(${baseX + gravityX}px, ${baseY + gravityY}px)`;
      } else {
        particle.style.transform = `translate(${baseX}px, ${baseY}px)`;
      }

      // Opacity-Animation
      if (progress < 0.1) {
        particle.style.opacity = `${opacity * (progress / 0.1)}`;
      } else if (progress > 0.9) {
        particle.style.opacity = `${opacity * ((1 - progress) / 0.1)}`;
      } else {
        particle.style.opacity = `${opacity * 0.8}`;
      }

      // Loop
      if (progress >= 1) {
        particle.style.top = `${-5 - Math.random() * 5}%`;
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.transform = 'translate(0, 0)';
      }

      requestAnimationFrame(updateFrame);
    };

    updateFrame();
  }

  /**
   * Erstellt einen riesigen Planeten - MEGALOPHOBIE!
   * Bewegt sich langsam von oben nach unten
   */
  function createPlanet(container: HTMLElement) {
    const planet = document.createElement('div');
    const size = CONFIG.planets.minSize + Math.random() * (CONFIG.planets.maxSize - CONFIG.planets.minSize);
    const planetType = CONFIG.planets.types[Math.floor(Math.random() * CONFIG.planets.types.length)];

    // Zufällige X-Position, teilweise außerhalb für dramatischen Effekt
    const startX = -20 + Math.random() * 140; // -20% bis 120%
    const rotation = Math.random() * 360;

    // Erstelle Gradient für den Planeten
    const gradient = `radial-gradient(circle at 35% 35%, ${planetType.colors[0]}, ${planetType.colors[1]} 40%, ${planetType.colors[2]} 80%, #00000088)`;

    planet.style.cssText = `
      position: absolute;
      width: ${size}px;
      height: ${size}px;
      background: ${gradient};
      border-radius: 50%;
      top: -${size + 100}px;
      left: ${startX}%;
      opacity: 0;
      box-shadow:
        inset -20px -20px 60px rgba(0,0,0,0.6),
        0 0 80px ${planetType.colors[1]}44,
        0 0 120px ${planetType.colors[1]}22;
      filter: blur(1px);
      transform: rotate(${rotation}deg);
      z-index: 10;
    `;

    container.appendChild(planet);

    const duration = CONFIG.planets.speed[0] + Math.random() * (CONFIG.planets.speed[1] - CONFIG.planets.speed[0]);
    const delay = Math.random() * 30000;
    const horizontalDrift = (Math.random() - 0.5) * 200;

    // Langsame, majestätische Bewegung von oben nach unten - wirkt bedrohlich groß
    animate(planet, {
      translateY: [0, window.innerHeight + size + 100],
      translateX: [0, horizontalDrift],
      rotate: [rotation, rotation + (Math.random() > 0.5 ? 30 : -30)],
      opacity: [
        { to: 0.7, duration: 3000 },
        { to: 0.9, duration: duration - 6000 },
        { to: 0, duration: 3000 },
      ],
      duration: duration,
      delay: delay,
      ease: 'linear',
      loop: true,
      onLoop: () => {
        // Neue Position und Type
        planet.style.left = `${-20 + Math.random() * 140}%`;
        planet.style.top = `-${size + 100}px`;
        const newType = CONFIG.planets.types[Math.floor(Math.random() * CONFIG.planets.types.length)];
        const newGradient = `radial-gradient(circle at 35% 35%, ${newType.colors[0]}, ${newType.colors[1]} 40%, ${newType.colors[2]} 80%, #00000088)`;
        planet.style.background = newGradient;
        planet.style.boxShadow = `
          inset -20px -20px 60px rgba(0,0,0,0.6),
          0 0 80px ${newType.colors[1]}44,
          0 0 120px ${newType.colors[1]}22
        `;
      },
    });
  }

  /**
   * Erstellt ein schwarzes Loch mit Akkretionsscheibe
   */
  function createBlackHole(container: HTMLElement) {
    const blackHole = document.createElement('div');
    const size = CONFIG.blackHole.minSize + Math.random() * (CONFIG.blackHole.maxSize - CONFIG.blackHole.minSize);
    const startX = -20 + Math.random() * 140;

    blackHole.style.cssText = `
      position: absolute;
      width: ${size}px;
      height: ${size}px;
      top: -${size + 100}px;
      left: ${startX}%;
      opacity: 0;
      z-index: 10;
    `;

    // Event Horizon (schwarzer Kreis)
    const horizon = document.createElement('div');
    horizon.style.cssText = `
      position: absolute;
      width: ${size * 0.3}px;
      height: ${size * 0.3}px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #000000;
      border-radius: 50%;
      box-shadow:
        0 0 ${size * 0.15}px ${size * 0.05}px rgba(0, 0, 0, 0.9),
        inset 0 0 ${size * 0.1}px rgba(0, 0, 0, 1);
    `;

    // Akkretionsscheibe (leuchtender Ring)
    const accretionDisk = document.createElement('div');
    accretionDisk.style.cssText = `
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: radial-gradient(
        circle,
        transparent 15%,
        rgba(59, 130, 246, 0.4) 25%,
        rgba(239, 68, 68, 0.6) 35%,
        rgba(251, 191, 36, 0.5) 45%,
        rgba(249, 115, 22, 0.3) 55%,
        transparent 70%
      );
      border-radius: 50%;
      filter: blur(3px);
    `;

    blackHole.appendChild(accretionDisk);
    blackHole.appendChild(horizon);
    container.appendChild(blackHole);

    const duration = CONFIG.blackHole.speed[0] + Math.random() * (CONFIG.blackHole.speed[1] - CONFIG.blackHole.speed[0]);
    const delay = Math.random() * 40000;
    const horizontalDrift = (Math.random() - 0.5) * 150;

    // Rotiere Akkretionsscheibe
    animate(accretionDisk, {
      rotate: [0, 360],
      duration: 20000,
      ease: 'linear',
      loop: true,
    });

    // Bewege schwarzes Loch
    animate(blackHole, {
      translateY: [0, window.innerHeight + size + 100],
      translateX: [0, horizontalDrift],
      opacity: [
        { to: 0.9, duration: 4000 },
        { to: 1, duration: duration - 8000 },
        { to: 0, duration: 4000 },
      ],
      duration: duration,
      delay: delay,
      ease: 'linear',
      loop: true,
      onLoop: () => {
        blackHole.style.left = `${-20 + Math.random() * 140}%`;
        blackHole.style.top = `-${size + 100}px`;
      },
    });
  }

  /**
   * Erstellt einen Meteor mit zufälliger Flugbahn
   */
  function createMeteor(container: HTMLElement) {
    const meteor = document.createElement('div');
    const height = CONFIG.meteors.height[0] + Math.random() * (CONFIG.meteors.height[1] - CONFIG.meteors.height[0]);
    const color = CONFIG.meteors.colors[Math.floor(Math.random() * CONFIG.meteors.colors.length)];

    // Zufällige Flugbahn: Winkel zwischen -45° und 45° von vertikal
    const angle = (Math.random() - 0.5) * 90; // -45 bis +45 Grad
    const rotation = 90 + angle; // 45 bis 135 Grad (relativ zu Horizontal)

    meteor.style.cssText = `
      position: absolute;
      width: ${CONFIG.meteors.width}px;
      height: ${height}px;
      background: linear-gradient(180deg, transparent, ${color});
      border-radius: 2px;
      top: ${-10 - Math.random() * 5}%;
      left: ${Math.random() * 100}%;
      opacity: 0;
      box-shadow: 0 0 10px ${color}, 0 0 20px ${color}66;
      z-index: 8;
      transform: rotate(${rotation}deg);
    `;

    container.appendChild(meteor);

    const duration = CONFIG.meteors.speed[0] + Math.random() * (CONFIG.meteors.speed[1] - CONFIG.meteors.speed[0]);
    const delay = CONFIG.meteors.delay[0] + Math.random() * (CONFIG.meteors.delay[1] - CONFIG.meteors.delay[0]);

    // Bewegungsrichtung basierend auf Winkel
    const horizontalDistance = Math.sin((angle * Math.PI) / 180) * window.innerHeight * 1.5;
    const verticalDistance = window.innerHeight * 1.3;

    // Animation: Flug entlang der zufälligen Flugbahn
    animate(meteor, {
      translateY: [0, verticalDistance],
      translateX: [0, horizontalDistance],
      opacity: [
        { to: 1, duration: 150 },
        { to: 0.9, duration: duration - 300 },
        { to: 0, duration: 150 },
      ],
      duration: duration,
      delay: delay,
      ease: 'linear',
      loop: true,
      onLoop: () => {
        // Neue Startposition und Winkel
        meteor.style.top = `${-10 - Math.random() * 5}%`;
        meteor.style.left = `${Math.random() * 100}%`;
        const newAngle = (Math.random() - 0.5) * 90;
        const newRotation = 90 + newAngle;
        meteor.style.transform = `rotate(${newRotation}deg)`;
      },
    });
  }

  /**
   * Initialisiert die Weltraum-Animation mit allen Layern
   * - Statische Sterne im Hintergrund
   * - Vorbeiziehende Partikel mit Parallax (oben nach unten)
   */
  function initSpaceAnimation() {
    const container = document.getElementById('space-bg');
    if (!container) return;

    // Leere Container bei Re-Init
    container.innerHTML = '';

    // STATISCHE STERNE (Hintergrund)
    // Layer 1: Weit entfernte Sterne
    for (let i = 0; i < CONFIG.starsDistant.count; i++) {
      createStar(container, CONFIG.starsDistant);
    }

    // Layer 2: Mittlere Entfernung
    for (let i = 0; i < CONFIG.starsMid.count; i++) {
      createStar(container, CONFIG.starsMid);
    }

    // Layer 3: Nahe Sterne
    for (let i = 0; i < CONFIG.starsNear.count; i++) {
      createStar(container, CONFIG.starsNear);
    }

    // VORBEIZIEHENDE PARTIKEL (von oben nach unten) - Parallax-Effekt
    // Langsame Partikel (Background) - z-index 2
    for (let i = 0; i < CONFIG.particles.count; i++) {
      createParticle(container, CONFIG.particles, 2);
    }

    // Mittlere Partikel - z-index 3
    for (let i = 0; i < CONFIG.particlesMid.count; i++) {
      createParticle(container, CONFIG.particlesMid, 3);
    }

    // Schnelle Partikel (Foreground) - z-index 4
    for (let i = 0; i < CONFIG.particlesNear.count; i++) {
      createParticle(container, CONFIG.particlesNear, 4);
    }

    // Riesige Planeten - MEGALOPHOBIE!
    for (let i = 0; i < CONFIG.planets.count; i++) {
      createPlanet(container);
    }

    // Schwarzes Loch
    for (let i = 0; i < CONFIG.blackHole.count; i++) {
      createBlackHole(container);
    }

    // Meteore mit zufälligen Flugbahnen
    for (let i = 0; i < CONFIG.meteors.count; i++) {
      createMeteor(container);
    }
  }

  /**
   * Cleanup bei View Transitions
   */
  function cleanup() {
    const container = document.getElementById('space-bg');
    if (container) {
      container.innerHTML = '';
    }
  }

  // Auto-Init
  if (typeof document !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initSpaceAnimation);
    } else {
      initSpaceAnimation();
    }

    // Astro View Transitions Support
    document.addEventListener('astro:before-swap', cleanup);
    document.addEventListener('astro:after-swap', initSpaceAnimation);
    document.addEventListener('astro:page-load', initSpaceAnimation);

    // Re-Init bei Theme-Wechsel (falls nötig)
    window.addEventListener('theme-changed', initSpaceAnimation);

    // Maus-Tracking für Gravitations-Effekt
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });
  }
</script>
