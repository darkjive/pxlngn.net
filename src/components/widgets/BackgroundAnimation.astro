---
/**
 * Space Background Animation - 3D Starfield
 *
 * Erzeugt einen intensiven animierten Weltraum-Hintergrund:
 * - 3D Starfield mit Z-Tiefe (Kirupa-Style)
 * - Statische Hintergrundsterne mit Twinkle
 *
 * Vermittelt das Gefühl von beklemmender Weite und Isolation im Weltraum.
 * Nutzt ausschließlich requestAnimationFrame für optimale Performance.
 */
---

<div id="space-bg" class="fixed inset-0 -z-50 hidden overflow-hidden bg-gradient-to-b from-black via-slate-950 to-black dark:block"></div>

<script>
  /**
   * Easing-Funktionen für weiche Animationen
   */
  const easing = {
    linear: (t: number) => t,
    inOutSine: (t: number) => -(Math.cos(Math.PI * t) - 1) / 2,
  };

  /**
   * Hilfsfunktion: Remap (wie bei Kirupa)
   */
  function remap(value: number, istart: number, istop: number, ostart: number, ostop: number): number {
    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
  }

  /**
   * Hilfsfunktion: Random Integer
   */
  function getRandomInt(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * Konfiguration für Partikeltypen - ALLES VIEL LANGSAMER
   */
  const CONFIG = {
    // Statische Sterne im Hintergrund (verschiedene Ebenen für Tiefe)
    starsDistant: {
      count: 300,
      minSize: 0.3,
      maxSize: 2,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#dbeafe', '#f0f9ff'],
      opacity: [0.15, 0.5],
      twinkle: true,
      twinkleDuration: [5000, 12000],
    },
    starsMid: {
      count: 200,
      minSize: 0.8,
      maxSize: 3,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#fef3c7', '#fef9c3', '#fefce8'],
      opacity: [0.3, 0.75],
      twinkle: true,
      twinkleDuration: [5000, 12000],
    },
    starsNear: {
      count: 120,
      minSize: 1.5,
      maxSize: 5,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#fef3c7', '#fde68a', '#fcd34d'],
      opacity: [0.5, 1],
      twinkle: true,
      twinkleDuration: [5000, 12000],
    },
    // 3D Starfield (Kirupa-Style)
    starfield: {
      count: 500,
      minSpeed: 0.1,
      maxSpeed: 0.5,
      maxDepth: 2000,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe'],
    },
  };

  /**
   * Animation-Manager für alle RAF-basierten Animationen
   */
  let animationId: number | null = null;

  /**
   * Erstellt einen statischen Stern mit leichtem Twinkle-Effekt
   */
  function createStar(container: HTMLElement, config: any) {
    const star = document.createElement('div');
    const size = config.minSize + Math.random() * (config.maxSize - config.minSize);
    const color = config.colors[Math.floor(Math.random() * config.colors.length)];
    const baseOpacity = config.opacity[0] + Math.random() * (config.opacity[1] - config.opacity[0]);

    star.style.cssText = `
      position: absolute;
      width: ${size}px;
      height: ${size}px;
      background: ${color};
      border-radius: 50%;
      box-shadow: 0 0 ${size * 2}px ${color};
      top: ${Math.random() * 100}%;
      left: ${Math.random() * 100}%;
      opacity: ${baseOpacity};
      z-index: 1;
    `;

    container.appendChild(star);

    // Leichtes Twinkle für Leben (optional)
    if (config.twinkle && Math.random() > 0.7) {
      const twinkleDuration = config.twinkleDuration[0] + Math.random() * (config.twinkleDuration[1] - config.twinkleDuration[0]);
      const startTime = Date.now() + Math.random() * 3000;
      const opacityMin = baseOpacity * 0.7;
      const opacityMax = baseOpacity * 1.3;

      const animateTwinkle = () => {
        const elapsed = Date.now() - startTime;
        const progress = (elapsed % twinkleDuration) / twinkleDuration;
        const easedProgress = easing.inOutSine(progress);

        // Oscillate zwischen min und max
        const opacity = progress < 0.5
          ? opacityMin + (opacityMax - opacityMin) * (easedProgress * 2)
          : opacityMax - (opacityMax - opacityMin) * ((easedProgress - 0.5) * 2);

        star.style.opacity = `${opacity}`;
      };

      // Registriere für Animation Loop
      (star as any).__animate = animateTwinkle;
    }
  }

  /**
   * Erstellt einen 3D Starfield-Stern (Kirupa-Style)
   * Punkt fliegt vom Hintergrund auf den Betrachter zu
   */
  function createStarfieldStar(container: HTMLElement) {
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    // Zufällige Position offset vom Zentrum
    let x = getRandomInt(-centerX, centerX);
    let y = getRandomInt(-centerY, centerY);

    // Z-Tiefe (counter): Je höher, desto weiter weg
    let counter = getRandomInt(1, CONFIG.starfield.maxDepth);

    // Random Eigenschaften
    const radiusMax = 1 + Math.random() * 10;
    let speed = CONFIG.starfield.minSpeed + Math.random() * (CONFIG.starfield.maxSpeed - CONFIG.starfield.minSpeed);
    const color = CONFIG.starfield.colors[Math.floor(Math.random() * CONFIG.starfield.colors.length)];

    // Erstelle Stern
    const star = document.createElement('div');
    star.style.cssText = `
      position: absolute;
      background: ${color};
      border-radius: 50%;
      box-shadow: 0 0 4px ${color};
      z-index: 5;
    `;

    container.appendChild(star);

    // Animation: Stern bewegt sich auf Betrachter zu
    const animateStarfield = () => {
      // Bewege Stern näher
      counter -= speed;

      // Reset wenn zu nah
      if (counter < 1) {
        counter = CONFIG.starfield.maxDepth;
        x = getRandomInt(-centerX, centerX);
        y = getRandomInt(-centerY, centerY);
        speed = CONFIG.starfield.minSpeed + Math.random() * (CONFIG.starfield.maxSpeed - CONFIG.starfield.minSpeed);
      }

      // Berechne Screen-Position basierend auf Z-Tiefe (3D Projektion)
      const xRatio = x / counter;
      const yRatio = y / counter;

      const starX = remap(xRatio, 0, 1, 0, window.innerWidth);
      const starY = remap(yRatio, 0, 1, 0, window.innerHeight);

      // Berechne Größe basierend auf Tiefe
      const radius = remap(counter, 0, CONFIG.starfield.maxDepth, radiusMax, 0);

      // Update Star
      star.style.left = `${starX}px`;
      star.style.top = `${starY}px`;
      star.style.width = `${radius * 2}px`;
      star.style.height = `${radius * 2}px`;

      // Opacity basierend auf Tiefe (näher = heller)
      const opacity = remap(counter, 0, CONFIG.starfield.maxDepth, 0.8, 0.1);
      star.style.opacity = `${opacity}`;
    };

    // Registriere für Animation Loop
    (star as any).__animate = animateStarfield;
  }

  /**
   * Unified Animation Loop
   */
  function animationLoop() {
    const container = document.getElementById('space-bg');
    if (!container) return;

    const elements = container.querySelectorAll('[style*="position: absolute"]');
    elements.forEach((el) => {
      const element = el as any;
      if (typeof element.__animate === 'function') {
        element.__animate();
      }
    });

    animationId = requestAnimationFrame(animationLoop);
  }

  /**
   * Initialisiert die Weltraum-Animation
   */
  function initSpaceAnimation() {
    const container = document.getElementById('space-bg');
    if (!container) return;

    if (animationId !== null) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }

    container.innerHTML = '';

    // STATISCHE STERNE (Hintergrund) - mit langsamerem Twinkle
    for (let i = 0; i < CONFIG.starsDistant.count; i++) {
      createStar(container, CONFIG.starsDistant);
    }

    for (let i = 0; i < CONFIG.starsMid.count; i++) {
      createStar(container, CONFIG.starsMid);
    }

    for (let i = 0; i < CONFIG.starsNear.count; i++) {
      createStar(container, CONFIG.starsNear);
    }

    // 3D STARFIELD (Kirupa-Style)
    for (let i = 0; i < CONFIG.starfield.count; i++) {
      createStarfieldStar(container);
    }

    animationLoop();
  }

  /**
   * Cleanup bei View Transitions
   */
  function cleanup() {
    if (animationId !== null) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }

    const container = document.getElementById('space-bg');
    if (container) {
      container.innerHTML = '';
    }
  }

  // Auto-Init
  if (typeof document !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initSpaceAnimation);
    } else {
      initSpaceAnimation();
    }

    document.addEventListener('astro:before-swap', cleanup);
    document.addEventListener('astro:after-swap', initSpaceAnimation);
    document.addEventListener('astro:page-load', initSpaceAnimation);

    window.addEventListener('theme-changed', initSpaceAnimation);
  }
</script>
