---
/**
 * Space Background Animation - Pure JavaScript
 *
 * Erzeugt einen intensiven animierten Weltraum-Hintergrund mit plain JS:
 * - Mehrere Ebenen von Sternen für Tiefeneffekt (Parallax)
 * - Riesige, langsam vorbeiziehende Planeten (Megalophobie)
 * - Schnelle Meteore mit Schweif
 * - Starfield-Effekt (Microsoft Bildschirmschoner Style)
 *
 * Vermittelt das Gefühl von beklemmender Weite und Isolation im Weltraum.
 * Nutzt ausschließlich requestAnimationFrame für optimale Performance.
 */
---

<div id="space-bg" class="fixed inset-0 -z-50 hidden overflow-hidden bg-gradient-to-b from-black via-slate-950 to-black dark:block"></div>

<script>
  /**
   * Easing-Funktionen für weiche Animationen
   */
  const easing = {
    linear: (t: number) => t,
    inOutSine: (t: number) => -(Math.cos(Math.PI * t) - 1) / 2,
  };

  /**
   * Konfiguration für Partikeltypen mit Tiefen-Layering
   * Statische Sterne + vertikale Bewegung (oben nach unten)
   */
  const CONFIG = {
    // Statische Sterne im Hintergrund (verschiedene Ebenen für Tiefe)
    starsDistant: {
      count: 300,
      minSize: 0.3,
      maxSize: 2,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#dbeafe', '#f0f9ff'],
      opacity: [0.15, 0.5],
      twinkle: true, // Leichtes Twinkle für Leben
    },
    starsMid: {
      count: 200,
      minSize: 0.8,
      maxSize: 3,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#fef3c7', '#fef9c3', '#fefce8'],
      opacity: [0.3, 0.75],
      twinkle: true,
    },
    starsNear: {
      count: 120,
      minSize: 1.5,
      maxSize: 5,
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe', '#fef3c7', '#fde68a', '#fcd34d'],
      opacity: [0.5, 1],
      twinkle: true,
    },
    // Starfield (wie Microsoft Bildschirmschoner)
    starfield: {
      count: 200,
      minSpeed: 1,
      maxSpeed: 5,
      acceleration: 1.005, // Beschleunigung
      colors: ['#ffffff', '#e0f2fe', '#bfdbfe'],
    },
    // Riesige Planeten (Megalophobie!) - von oben nach unten
    planets: {
      count: 4,
      minSize: 300,
      maxSize: 800,
      speed: [60000, 120000], // Sehr langsam, majestätisch
      types: [
        { colors: ['#1e3a8a', '#3b82f6', '#1e40af'], name: 'gas-giant' },
        { colors: ['#dc2626', '#f87171', '#7f1d1d'], name: 'red-planet' },
        { colors: ['#f59e0b', '#fbbf24', '#92400e'], name: 'desert-world' },
        { colors: ['#059669', '#10b981', '#064e3b'], name: 'toxic-world' },
        { colors: ['#6366f1', '#a855f7', '#4c1d95'], name: 'purple-giant' },
      ],
    },
    // Meteore mit zufälligen Flugbahnen
    meteors: {
      count: 8,
      width: 2,
      height: [40, 120],
      speed: [1200, 3000],
      colors: ['#60a5fa', '#3b82f6', '#2563eb', '#ffffff', '#f0f9ff'],
      delay: [0, 20000],
    },
  };

  /**
   * Aktive Planeten für Kollisionsvermeidung
   */
  const activePlanets: Array<{ x: number; y: number; size: number; vx: number; vy: number }> = [];

  /**
   * Animation-Manager für alle RAF-basierten Animationen
   */
  let animationId: number | null = null;

  /**
   * Erstellt einen statischen Stern mit leichtem Twinkle-Effekt
   */
  function createStar(container: HTMLElement, config: typeof CONFIG.starsDistant) {
    const star = document.createElement('div');
    const size = config.minSize + Math.random() * (config.maxSize - config.minSize);
    const color = config.colors[Math.floor(Math.random() * config.colors.length)];
    const baseOpacity = config.opacity[0] + Math.random() * (config.opacity[1] - config.opacity[0]);

    star.style.cssText = `
      position: absolute;
      width: ${size}px;
      height: ${size}px;
      background: ${color};
      border-radius: 50%;
      box-shadow: 0 0 ${size * 2}px ${color};
      top: ${Math.random() * 100}%;
      left: ${Math.random() * 100}%;
      opacity: ${baseOpacity};
      z-index: 1;
    `;

    container.appendChild(star);

    // Leichtes Twinkle für Leben (optional)
    if (config.twinkle && Math.random() > 0.7) {
      const twinkleDuration = 2000 + Math.random() * 3000;
      const startTime = Date.now() + Math.random() * 2000; // Zufälliger Start-Offset
      const opacityMin = baseOpacity * 0.7;
      const opacityMax = baseOpacity * 1.3;

      const animateTwinkle = () => {
        const elapsed = Date.now() - startTime;
        const progress = (elapsed % twinkleDuration) / twinkleDuration;
        const easedProgress = easing.inOutSine(progress);

        // Oscillate zwischen min und max
        const opacity = progress < 0.5
          ? opacityMin + (opacityMax - opacityMin) * (easedProgress * 2)
          : opacityMax - (opacityMax - opacityMin) * ((easedProgress - 0.5) * 2);

        star.style.opacity = `${opacity}`;
      };

      // Registriere für Animation Loop
      (star as any).__animate = animateTwinkle;
    }
  }

  /**
   * Erstellt einen Starfield-Stern (klassischer Windows Starfield Style)
   * Punkt fliegt vom Zentrum nach außen und wird zu einer Linie
   */
  function createStarfieldStar(container: HTMLElement) {
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    // Zufällige Richtung
    let angle = Math.random() * Math.PI * 2;

    // Start sehr nah am Zentrum
    let x = centerX + Math.cos(angle) * (Math.random() * 10);
    let y = centerY + Math.sin(angle) * (Math.random() * 10);

    // Initial Geschwindigkeit
    let speed = CONFIG.starfield.minSpeed + Math.random() * (CONFIG.starfield.maxSpeed - CONFIG.starfield.minSpeed);

    const color = CONFIG.starfield.colors[Math.floor(Math.random() * CONFIG.starfield.colors.length)];

    // Erstelle Stern-Linie (stretched dot)
    const star = document.createElement('div');
    star.style.cssText = `
      position: absolute;
      width: 2px;
      height: 2px;
      background: ${color};
      box-shadow: 0 0 2px ${color};
      left: ${x}px;
      top: ${y}px;
      z-index: 5;
      transform-origin: center;
    `;

    container.appendChild(star);

    // Animation mit Beschleunigung
    const animateStarfield = () => {
      // Beschleunigung: Je weiter vom Zentrum, desto schneller
      speed *= CONFIG.starfield.acceleration;

      // Bewege Stern
      x += Math.cos(angle) * speed;
      y += Math.sin(angle) * speed;

      // Berechne Länge basierend auf Geschwindigkeit (Motion Blur)
      const length = Math.min(speed * 2, 20);
      const width = Math.max(0.5, Math.min(speed * 0.3, 2));

      // Update Star als Linie
      star.style.left = `${x}px`;
      star.style.top = `${y}px`;
      star.style.width = `${width}px`;
      star.style.height = `${length}px`;
      star.style.transform = `rotate(${angle}rad)`;

      // Opacity basierend auf Geschwindigkeit
      const opacity = Math.min(0.8, speed / 10);
      star.style.opacity = `${opacity}`;

      // Reset wenn außerhalb Bildschirm
      if (
        x < -50 ||
        x > window.innerWidth + 50 ||
        y < -50 ||
        y > window.innerHeight + 50
      ) {
        // Neuer Stern vom Zentrum
        angle = Math.random() * Math.PI * 2;
        x = centerX + Math.cos(angle) * (Math.random() * 10);
        y = centerY + Math.sin(angle) * (Math.random() * 10);
        speed = CONFIG.starfield.minSpeed + Math.random() * (CONFIG.starfield.maxSpeed - CONFIG.starfield.minSpeed);
      }
    };

    // Registriere für Animation Loop
    (star as any).__animate = animateStarfield;
  }

  /**
   * Prüft ob eine Position mit existierenden Planeten kollidiert
   */
  function checkCollision(x: number, y: number, size: number): boolean {
    for (const planet of activePlanets) {
      const dx = x - planet.x;
      const dy = y - planet.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDistance = (size + planet.size) / 2 + 100; // 100px Mindestabstand

      if (distance < minDistance) {
        return true; // Kollision!
      }
    }
    return false;
  }

  /**
   * Findet eine kollisionsfreie Startposition für einen Planeten
   */
  function findSafePosition(size: number): { x: number; y: number } {
    let attempts = 0;
    const maxAttempts = 50;

    while (attempts < maxAttempts) {
      const x = (Math.random() * 140 - 20) * (window.innerWidth / 100); // -20% bis 120%
      const y = -(size + 100);

      if (!checkCollision(x, y, size)) {
        return { x, y };
      }
      attempts++;
    }

    // Fallback: Position ganz links oder rechts
    const x = Math.random() > 0.5 ? -size - 200 : window.innerWidth + 200;
    return { x, y: -(size + 100) };
  }

  /**
   * Erstellt einen riesigen Planeten - MEGALOPHOBIE!
   * Bewegt sich langsam von oben nach unten, KEINE Überlappung
   */
  function createPlanet(container: HTMLElement) {
    const planet = document.createElement('div');
    const size = CONFIG.planets.minSize + Math.random() * (CONFIG.planets.maxSize - CONFIG.planets.minSize);
    const planetType = CONFIG.planets.types[Math.floor(Math.random() * CONFIG.planets.types.length)];

    // Finde kollisionsfreie Startposition
    const { x: startX, y: startY } = findSafePosition(size);
    const initialRotation = Math.random() * 360;

    // Realistischer Gradient OHNE Transparenz
    const gradient = `radial-gradient(circle at 35% 35%, ${planetType.colors[0]}, ${planetType.colors[1]} 40%, ${planetType.colors[2]} 80%, ${planetType.colors[2]})`;

    planet.style.cssText = `
      position: absolute;
      width: ${size}px;
      height: ${size}px;
      background: ${gradient};
      border-radius: 50%;
      left: ${startX}px;
      top: ${startY}px;
      opacity: 1;
      box-shadow:
        inset -30px -30px 80px rgba(0,0,0,0.7),
        0 0 100px ${planetType.colors[1]}66,
        0 0 150px ${planetType.colors[1]}33;
      z-index: 10;
      will-change: transform;
    `;

    container.appendChild(planet);

    const duration = CONFIG.planets.speed[0] + Math.random() * (CONFIG.planets.speed[1] - CONFIG.planets.speed[0]);
    const delay = Math.random() * 30000;
    const horizontalDrift = (Math.random() - 0.5) * 200;
    const rotationChange = Math.random() > 0.5 ? 30 : -30;

    // Registriere Planet für Kollisionserkennung
    const planetData = {
      x: startX + size / 2,
      y: startY + size / 2,
      size: size,
      vx: horizontalDrift / duration,
      vy: (window.innerHeight + size + 100) / duration,
    };
    activePlanets.push(planetData);

    // Animation State
    const startTime = Date.now() + delay;
    const totalDistance = window.innerHeight + size + 100;

    const animatePlanet = () => {
      const now = Date.now();
      if (now < startTime) return; // Warte auf Delay

      const elapsed = now - startTime;
      const progress = (elapsed % duration) / duration;

      // Linear easing für gleichmäßige Bewegung
      const translateY = progress * totalDistance;
      const translateX = progress * horizontalDrift;
      const rotation = initialRotation + progress * rotationChange;

      planet.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotation}deg)`;

      // Update Kollisionsdaten
      planetData.x = startX + translateX + size / 2;
      planetData.y = startY + translateY + size / 2;

      // Loop: Reset bei Ende
      if (progress >= 0.999) {
        // Neue kollisionsfreie Position
        const { x: newX, y: newY } = findSafePosition(size);
        planet.style.left = `${newX}px`;
        planet.style.top = `${newY}px`;
        planet.style.transform = 'none';

        // Update Planet-Daten
        planetData.x = newX + size / 2;
        planetData.y = newY + size / 2;

        // Neuer Planeten-Typ
        const newType = CONFIG.planets.types[Math.floor(Math.random() * CONFIG.planets.types.length)];
        const newGradient = `radial-gradient(circle at 35% 35%, ${newType.colors[0]}, ${newType.colors[1]} 40%, ${newType.colors[2]} 80%, ${newType.colors[2]})`;
        planet.style.background = newGradient;
        planet.style.boxShadow = `
          inset -30px -30px 80px rgba(0,0,0,0.7),
          0 0 100px ${newType.colors[1]}66,
          0 0 150px ${newType.colors[1]}33
        `;

        // Restart Animation
        (planet as any).__startTime = Date.now();
      }
    };

    // Registriere für Animation Loop
    (planet as any).__animate = animatePlanet;
    (planet as any).__startTime = startTime;
  }

  /**
   * Erstellt einen Meteor mit zufälliger Flugbahn
   */
  function createMeteor(container: HTMLElement) {
    const meteor = document.createElement('div');
    const height = CONFIG.meteors.height[0] + Math.random() * (CONFIG.meteors.height[1] - CONFIG.meteors.height[0]);
    const color = CONFIG.meteors.colors[Math.floor(Math.random() * CONFIG.meteors.colors.length)];

    // Zufällige Flugbahn: Winkel zwischen -45° und 45° von vertikal
    const angle = (Math.random() - 0.5) * 90; // -45 bis +45 Grad
    const rotation = 90 + angle; // 45 bis 135 Grad (relativ zu Horizontal)

    meteor.style.cssText = `
      position: absolute;
      width: ${CONFIG.meteors.width}px;
      height: ${height}px;
      background: linear-gradient(180deg, transparent, ${color});
      border-radius: 2px;
      top: ${-10 - Math.random() * 5}%;
      left: ${Math.random() * 100}%;
      opacity: 0;
      box-shadow: 0 0 10px ${color}, 0 0 20px ${color}66;
      z-index: 8;
      transform: rotate(${rotation}deg);
      will-change: transform, opacity;
    `;

    container.appendChild(meteor);

    const duration = CONFIG.meteors.speed[0] + Math.random() * (CONFIG.meteors.speed[1] - CONFIG.meteors.speed[0]);
    const delay = CONFIG.meteors.delay[0] + Math.random() * (CONFIG.meteors.delay[1] - CONFIG.meteors.delay[0]);

    // Bewegungsrichtung basierend auf Winkel
    const horizontalDistance = Math.sin((angle * Math.PI) / 180) * window.innerHeight * 1.5;
    const verticalDistance = window.innerHeight * 1.3;

    // Speichere Startposition
    const startTop = meteor.style.top;
    const startLeft = meteor.style.left;

    // Animation State
    const startTime = Date.now() + delay;

    const animateMeteor = () => {
      const now = Date.now();
      if (now < startTime) return; // Warte auf Delay

      const elapsed = now - startTime;
      const progress = (elapsed % duration) / duration;

      // Linear movement
      const translateY = progress * verticalDistance;
      const translateX = progress * horizontalDistance;

      // Opacity fade in/out
      let opacity: number;
      if (progress < 0.05) {
        // Fade in ersten 5%
        opacity = progress / 0.05;
      } else if (progress > 0.95) {
        // Fade out letzten 5%
        opacity = (1 - progress) / 0.05;
      } else {
        opacity = 0.9;
      }

      meteor.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotation}deg)`;
      meteor.style.opacity = `${opacity}`;

      // Loop: Reset bei Ende
      if (progress >= 0.999) {
        // Neue Startposition und Winkel
        meteor.style.top = `${-10 - Math.random() * 5}%`;
        meteor.style.left = `${Math.random() * 100}%`;
        meteor.style.transform = 'none';
        meteor.style.opacity = '0';

        const newAngle = (Math.random() - 0.5) * 90;
        const newRotation = 90 + newAngle;

        // Update für nächsten Loop
        (meteor as any).__angle = newAngle;
        (meteor as any).__rotation = newRotation;
        (meteor as any).__horizontalDistance = Math.sin((newAngle * Math.PI) / 180) * window.innerHeight * 1.5;
        (meteor as any).__startTime = Date.now();
      }
    };

    // Speichere Animation-Daten
    (meteor as any).__animate = animateMeteor;
    (meteor as any).__startTime = startTime;
    (meteor as any).__angle = angle;
    (meteor as any).__rotation = rotation;
    (meteor as any).__horizontalDistance = horizontalDistance;
  }

  /**
   * Unified Animation Loop
   * Sammelt alle Animationen in einem einzigen RAF Loop für optimale Performance
   */
  function animationLoop() {
    const container = document.getElementById('space-bg');
    if (!container) return;

    // Animiere alle Elemente die eine __animate Funktion haben
    const elements = container.querySelectorAll('[style*="position: absolute"]');
    elements.forEach((el) => {
      const element = el as any;
      if (typeof element.__animate === 'function') {
        element.__animate();
      }
    });

    animationId = requestAnimationFrame(animationLoop);
  }

  /**
   * Initialisiert die Weltraum-Animation mit allen Layern
   * - Statische Sterne im Hintergrund
   * - Starfield-Effekt (Microsoft Bildschirmschoner Style)
   * - Riesige Planeten ohne Überlappung
   * - Meteore mit zufälligen Flugbahnen
   */
  function initSpaceAnimation() {
    const container = document.getElementById('space-bg');
    if (!container) return;

    // Stoppe alte Animation
    if (animationId !== null) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }

    // Leere Container bei Re-Init
    container.innerHTML = '';
    activePlanets.length = 0;

    // STATISCHE STERNE (Hintergrund)
    // Layer 1: Weit entfernte Sterne
    for (let i = 0; i < CONFIG.starsDistant.count; i++) {
      createStar(container, CONFIG.starsDistant);
    }

    // Layer 2: Mittlere Entfernung
    for (let i = 0; i < CONFIG.starsMid.count; i++) {
      createStar(container, CONFIG.starsMid);
    }

    // Layer 3: Nahe Sterne
    for (let i = 0; i < CONFIG.starsNear.count; i++) {
      createStar(container, CONFIG.starsNear);
    }

    // STARFIELD (Microsoft Bildschirmschoner Style)
    for (let i = 0; i < CONFIG.starfield.count; i++) {
      createStarfieldStar(container);
    }

    // Riesige Planeten - MEGALOPHOBIE! (keine Überlappung)
    for (let i = 0; i < CONFIG.planets.count; i++) {
      createPlanet(container);
    }

    // Meteore mit zufälligen Flugbahnen
    for (let i = 0; i < CONFIG.meteors.count; i++) {
      createMeteor(container);
    }

    // Starte Unified Animation Loop
    animationLoop();
  }

  /**
   * Cleanup bei View Transitions
   */
  function cleanup() {
    // Stoppe Animation Loop
    if (animationId !== null) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }

    const container = document.getElementById('space-bg');
    if (container) {
      container.innerHTML = '';
    }

    // Leere Planeten-Array für Kollisionserkennung
    activePlanets.length = 0;
  }

  // Auto-Init
  if (typeof document !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initSpaceAnimation);
    } else {
      initSpaceAnimation();
    }

    // Astro View Transitions Support
    document.addEventListener('astro:before-swap', cleanup);
    document.addEventListener('astro:after-swap', initSpaceAnimation);
    document.addEventListener('astro:page-load', initSpaceAnimation);

    // Re-Init bei Theme-Wechsel (falls nötig)
    window.addEventListener('theme-changed', initSpaceAnimation);
  }
</script>
